---
title: web安全
date: 2019-07-24
categories: 前端安全
tags:
  - 前端安全
comments: true
cover_picture: /images/banner.jpg
---

### xss

XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS 重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。
**跨站脚本攻击有可能造成以下影响:**
利用虚假输入表单骗取用户个人信息。
利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
显示伪造的文章或图片。
XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。
**类型**
反射性 xss
存储型 xss
**如何防御**
**1）CSP**
CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。
通常可以通过两种方式来开启 CSP：
设置 HTTP Header 中的 Content-Security-Policy
设置 meta 标签的方式
**2）转义字符**
用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义
但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

```javascript
const xss = require("xss");
let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>');
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html);
```

以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。
**3）HttpOnly Cookie**
这是预防 XSS 攻击窃取用户 cookie 最有效的防御手段。Web 应用程序在设置 cookie 时，将其属性设为 HttpOnly，就可以避免该网页的 cookie 被客户端恶意 JavaScript 窃取，保护用户 cookie 信息。

### csrf

CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的 Web 攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。

![1560763356250](http://i1.fuimg.com/695012/997336e1a7752be5.png)
**如何防御**
**1) SameSite**
可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。
**2) Referer**
HTTP Referer 是 header 的一部分，当浏览器向 web 服务器发送请求时，一般会带上 Referer 信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御 CSRF 攻击。正常请求的 referer 具有一定规律，如在提交表单的 referer 必定是在该页面发起的请求。所以通过检查 http 包头 referer 的值是不是这个页面，来判断是不是 CSRF 攻击。
**3) Anti CSRF Token**
目前比较完善的解决方案是加入 Anti-CSRF-Token。即发送请求时在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器建立一个拦截器来验证这个 token。服务器读取浏览器当前域 cookie 中这个 token 值，会进行校验该请求当中的 token 和 cookie 当中的 token 值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。
这种方法相比 Referer 检查要安全很多，token 可以在用户登陆后产生并放于 session 或 cookie 中，然后在每次请求时服务器把 token 从 session 或 cookie 中拿出，与本次请求中的 token 进行比对。由于 token 的存在，攻击者无法再构造出一个完整的 URL 实施 CSRF 攻击。但在处理多个页面共存问题时，当某个页面消耗掉 token 后，其他页面的表单保存的还是被消耗掉的那个 token，其他页面的表单提交时会出现 token 错误。
**4) 验证码**
应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制 CSRF 攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。

### 点击劫持(操作是用户完成，但非用户意愿)

将目标网站通过 iframe 嵌入到攻击网站中，设置 iframe 的透明度为 0（隐藏），通过对用户的点击引导，使其做一些指定的操作
用户亲手操作、用户不知情、盗取用户资金、获取用户敏感信息
**防御方法：**
**1）JavaScript 禁止内嵌**
​ if(top.location!==window.location){top.location=window.location}
​ 仍然存在劫持的可能性，因为攻击者可能禁止了 js 脚本，如在 iframe 中添加 sandbox 属性
**2）X-FRAME-OPTIONS 禁止内嵌**
​ 兼容性相当好（推荐）
​ X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。
​ 该响应头有三个值可选，分别是
​ DENY，表示页面不允许通过 iframe 的方式展示
​ SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
​ ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示

### URL 跳转漏洞

黑客利用 URL 跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接(链接需要进行伪装,尽可能迷惑),发在 QQ 群或者是浏览量多的贴吧/论坛中。
安全意识低的用户点击后,经过服务器或者浏览器解析后，跳到恶意的网站中。
**如何防御**
**1)referer 的限制**
如果确定传递 URL 参数进入的来源，我们可以通过该方式实现安全限制，保证该 URL 的有效性，避免恶意用户自己生成跳转链接
**2)加入有效性验证 Token**
我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的 Token 对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。

### SQL 注入

**1、SQL 注入攻击**
​ 探测是否存在 sql 注入问题（加恒等条件和恒不等条件）——涉及到信息泄露的问题
​ 探测服务器数据库版本号（使用 version 函数，此版本存在哪些漏洞）
​ 探测数据表的字段个数和字段名（使用 union）——可以拿到字段名和具体数据了
​ 危害：猜解密码、获取数据、删库删表
**2、SQL 注入防御**
​ 关闭错误输出（不抛出具体错误）
​ 检查数据类型（期待输入类型）
​ 对数据进行转义（带引号、sql 语句的全部转移掉，保证传入的永远是字符串）
​ 使用参数化查询方案（使用问号?）
​ 使用 ORM（如 sequelize，不需要使用 sql 语句）
**3、NoSQL 注入和防御**
​ 检查数据类型
​ 类型转换
​ 写完整条件

### OS 命令注入攻击

OS 命令注入和 SQL 注入差不多，只不过 SQL 注入是针对数据库的，而 OS 命令注入是针对操作系统的。OS 命令注入攻击指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。倘若调用 Shell 时存在疏漏，就可以执行插入的非法命令。
命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。
**如何防御**
后端对前端提交内容进行规则限制（比如正则表达式）。
在调用系统命令前对所有传入参数进行命令行参数转义过滤。
不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm 包

### 传输安全

**1、http 窃听**（因为是明文传输，因此会产生传输链路的窃听和篡改）
​ http 篡改：插入广告、重定向网站、无法防御的 xss 和 csrf 攻击
​ 案例：运营商劫持、局域网劫持、公共 wifi 获取密码
**2、https**
​ 将明文变为密文（TLS，也叫做 SSL，加密），到达目的地后解密
​ 如何确定服务器身份

![1560759758513](http://i1.fuimg.com/695012/39b151e95ef8159c.png)

### 密码安全

1、泄露渠道：数据库被偷、服务器被入侵、通讯被窃听、内部人员泄露数据、其他网站（撞库）
2、防御：严谨密码明文存储、单向变化、变换复杂度要求、密码复杂度要求、加盐
​ 单向变化：哈希算法（明文-密文一一对应、雪崩效应、密文-明文无法反推、密文固定长度），常见哈希算法：md5、sha1、sha256

加密成本几乎不变（生成密码时速度慢一些）
彩虹表失效（数据量太大，无法建立通用性）
解密成本增大 N 倍
3、用户密码加固（加 salt 变换后存储）
4、密码传输的安全性（https 传输、频率限制、前端加密意义有限）
5、生物特征密码（指纹、声纹、虹膜、人脸等）——需要保持谨慎的态度
​ 缺少私密性（容易泄露，如通过照片可以识别指纹达到破解的目的）
​ 安全性——碰撞（相似性，如人脸受伤产生的变化，会有一定的容错性，可能会导致一些判断错误）
​ 唯一性（终身唯一，无法修改）

### cookie 安全

xss 可能偷取 cookie（http-only 的 cookie 不会被盗取）
csrf 利用了用户的 cookie（攻击站点无法读取 cookie）
cookie 安全问题：
​ 1）cookie 被篡改，推荐使用 userId+签名
​ 2）cookie 被盗
cookie 安全策略：
​ 1）签名防篡改
​ 2）私有变换（加密）
​ 3）http-only（防止 xss）
​ 4）secure
​ 5）same-site（兼容性不是很好）

### 接入层上传问题

上传问题（上传的文件当成程序解析）
防御：
1）限制上传后缀
2）文件类型检查
3）文件内容检查
4）程序输出
5）权限控制

### 其他问题

**DOS 攻击**

DoS 是 Denial of Service 的简称，即拒绝服务，造成 DoS 的攻击行为被称为 DoS 攻击，其目的是使计算机或网络无法提供正常的服务。最常见的 DoS 攻击有计算机网络带宽攻击和连通性攻击。 [1]

DoS 攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。

**重放攻击**

重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用[网络监听](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%9B%91%E5%90%AC/10914318)或者其他方式盗取认证凭据，之后再把它重新发给[认证服务器](https://baike.baidu.com/item/%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8)。重放攻击在任何网络通过程中都可能发生，是计算机世界[黑客](https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2/118396)常用的攻击方式之一。

加密 https、加时间戳、token、nonce、签名

### 问题:

1）xss 原理、xss 防御、xss 防御需要注意的点
2）csrf 原理、危害、csrf 防御
3）cookies 作用、和其他存储方式的区别、cookies 和 session 的关系、cookies 有哪些特性、属性、如何删除一个 cookie（设置过期时间为过去的时间即可）
4）https 是如何保证数据不被窃听、https 如何保证不被中间人攻击（证书机制)、部署 https 的步骤
5）SQL 注入的原理、危害、nodejs 如何防止 sql 注入（ORM、参数化查询）
6）文件上传漏洞的原理、如何防范文件上传漏洞
7）如何设计用户密码存储、如何设计登录过程、如何保证密码不被窃听
