---
title: web安全
date: 2019-07-24
categories: 前端安全
tags:
  - 前端安全
comments: true
cover_picture: /images/banner.jpg
---

### xss
XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。
**跨站脚本攻击有可能造成以下影响:**
利用虚假输入表单骗取用户个人信息。
利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
显示伪造的文章或图片。
XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。
**类型**
反射性xss
存储型xss
**如何防御**
**1）CSP**
CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。
通常可以通过两种方式来开启 CSP：
设置 HTTP Header 中的 Content-Security-Policy
设置 meta 标签的方式
**2）转义字符**
用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义
但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

```javascript
const xss = require('xss')
let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html)
```
以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。
**3）HttpOnly Cookie**
这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。

### csrf
CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。

![1560763356250](http://i1.fuimg.com/695012/997336e1a7752be5.png)
**如何防御**
**1) SameSite**
可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。
**2) Referer** 
HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。
**3) Anti CSRF Token**
目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。
这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。
**4) 验证码**
应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。

### 点击劫持(操作是用户完成，但非用户意愿)
将目标网站通过iframe嵌入到攻击网站中，设置iframe的透明度为0（隐藏），通过对用户的点击引导，使其做一些指定的操作
用户亲手操作、用户不知情、盗取用户资金、获取用户敏感信息
**防御方法：**
**1）JavaScript禁止内嵌**
​    if(top.location!==window.location){top.location=window.location} 
​    仍然存在劫持的可能性，因为攻击者可能禁止了js脚本，如在iframe中添加sandbox属性
**2）X-FRAME-OPTIONS禁止内嵌**
​    兼容性相当好（推荐）
​    X-FRAME-OPTIONS是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。
​    该响应头有三个值可选，分别是
​    DENY，表示页面不允许通过 iframe 的方式展示
​    SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
​    ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示

### URL跳转漏洞
黑客利用URL跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接(链接需要进行伪装,尽可能迷惑),发在QQ群或者是浏览量多的贴吧/论坛中。
安全意识低的用户点击后,经过服务器或者浏览器解析后，跳到恶意的网站中。
**如何防御**
**1)referer的限制**
如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接
**2)加入有效性验证Token**
我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。

### SQL注入
**1、SQL注入攻击**
​    探测是否存在sql注入问题（加恒等条件和恒不等条件）——涉及到信息泄露的问题
​    探测服务器数据库版本号（使用version函数，此版本存在哪些漏洞）
​    探测数据表的字段个数和字段名（使用union）——可以拿到字段名和具体数据了
​    危害：猜解密码、获取数据、删库删表
**2、SQL注入防御**
​    关闭错误输出（不抛出具体错误）
​    检查数据类型（期待输入类型）
​    对数据进行转义（带引号、sql语句的全部转移掉，保证传入的永远是字符串）
​    使用参数化查询方案（使用问号?）
​    使用ORM（如sequelize，不需要使用sql语句）
**3、NoSQL注入和防御**
​    检查数据类型
​    类型转换
​    写完整条件

### OS命令注入攻击
OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。倘若调用Shell时存在疏漏，就可以执行插入的非法命令。
命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。
**如何防御**
后端对前端提交内容进行规则限制（比如正则表达式）。
在调用系统命令前对所有传入参数进行命令行参数转义过滤。
不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm包

### 传输安全
**1、http窃听**（因为是明文传输，因此会产生传输链路的窃听和篡改）
​    http篡改：插入广告、重定向网站、无法防御的xss和csrf攻击
​    案例：运营商劫持、局域网劫持、公共wifi获取密码
**2、https**
​    将明文变为密文（TLS，也叫做SSL，加密），到达目的地后解密
​    如何确定服务器身份

![1560759758513](http://i1.fuimg.com/695012/39b151e95ef8159c.png)

### 密码安全
1、泄露渠道：数据库被偷、服务器被入侵、通讯被窃听、内部人员泄露数据、其他网站（撞库）
2、防御：严谨密码明文存储、单向变化、变换复杂度要求、密码复杂度要求、加盐
​    单向变化：哈希算法（明文-密文一一对应、雪崩效应、密文-明文无法反推、密文固定长度），常见哈希算法：md5、sha1、sha256

加密成本几乎不变（生成密码时速度慢一些）
彩虹表失效（数据量太大，无法建立通用性）
解密成本增大N倍
3、用户密码加固（加salt变换后存储）
4、密码传输的安全性（https传输、频率限制、前端加密意义有限）
5、生物特征密码（指纹、声纹、虹膜、人脸等）——需要保持谨慎的态度
​    缺少私密性（容易泄露，如通过照片可以识别指纹达到破解的目的）
​    安全性——碰撞（相似性，如人脸受伤产生的变化，会有一定的容错性，可能会导致一些判断错误）
​    唯一性（终身唯一，无法修改）

### cookie安全
xss可能偷取cookie（http-only的cookie不会被盗取）
csrf利用了用户的cookie（攻击站点无法读取cookie）
cookie安全问题：
​    1）cookie被篡改，推荐使用userId+签名 
​    2）cookie被盗
cookie安全策略：
​    1）签名防篡改 
​    2）私有变换（加密） 
​    3）http-only（防止xss） 
​    4）secure 
​    5）same-site（兼容性不是很好）

### 接入层上传问题
上传问题（上传的文件当成程序解析）
防御：
1）限制上传后缀
2）文件类型检查
3）文件内容检查
4）程序输出
5）权限控制

### 其他问题
**DOS攻击**

DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。 [1] 

DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。 

**重放攻击**

重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用[网络监听](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%9B%91%E5%90%AC/10914318)或者其他方式盗取认证凭据，之后再把它重新发给[认证服务器](https://baike.baidu.com/item/%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8)。重放攻击在任何网络通过程中都可能发生，是计算机世界[黑客](https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2/118396)常用的攻击方式之一。

加密https、加时间戳、token、nonce、签名

### 问题:
1）xss原理、xss防御、xss防御需要注意的点
2）csrf原理、危害、csrf防御
3）cookies作用、和其他存储方式的区别、cookies和session的关系、cookies有哪些特性、属性、如何删除一个cookie（设置过期时间为过去的时间即可）
4）https是如何保证数据不被窃听、https如何保证不被中间人攻击（证书机制)、部署https的步骤
5）SQL注入的原理、危害、nodejs如何防止sql注入（ORM、参数化查询）
6）文件上传漏洞的原理、如何防范文件上传漏洞
7）如何设计用户密码存储、如何设计登录过程、如何保证密码不被窃听