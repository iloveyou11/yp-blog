---
title: 目标检测精华版本
date: 2020-04-06
categories: AI
author: yangpei
comments: true
cover_picture: /images/banner.jpg
---

这里，介绍目标检测的基础算法及原理。

<!-- more -->

### CNN扩展知识
#### 1x1卷积
作用：
1. 可以增加模型的非线性性（相当于在不改变特征尺寸的基础上，额外引入了一个非线性层，使用非线性激活函数）
2. 进行特征降维，可以将多通道的特征图压缩到更小的channel（主要目的）

其中，1x1卷积的主要作用是为了特征降维，能极大地减少计算量，在GoogLeNet的Inception架构中，引入了1x1卷积来简化计算。

<img width="60%" src="https://i.loli.net/2020/04/06/HaqK5wDLAsPTEzC.jpg" alt="1x1卷积" />

以下是GoogLeNet的Inception结构，其中就应用到了1x1的卷积，极大地简化了计算量：

<img width="60%" src="https://i.loli.net/2020/04/06/isyzG24B3f5HYeA.jpg" alt="1x1卷积减少计算量" />

#### 空洞卷积

<img width="60%"  src="https://i.loli.net/2020/04/06/4jDPpI5Ub2o7Tne.jpg" alt="空洞卷积" />

#### 转置卷积（反卷积）

<img width="60%" src="https://i.loli.net/2020/04/06/ybJ71TREC8AloNU.jpg" alt="转置卷积" />

### 目标检测算法
**判断目标检测结果好坏的指标：**
1. 模型检测速度fps
2. mAP—平均准确率均值

<img width="50%"  src="https://i.loli.net/2020/04/06/MQ7x8EfZk9JiBta.jpg" alt="mAP" />

计算方法：

<img width="50%" src="https://i.loli.net/2020/04/06/oTMuY25gpdIaeGf.jpg" alt="mAP计算方法" />

**one-stage vs two stage的目标检测算法：**

<img width="50%" src="https://i.loli.net/2020/04/07/182xYpwVW9jXGq6.jpg" alt="one and two" />

<img width="50%" src="https://i.loli.net/2020/04/07/3cwfBMvyaSDolb5.jpg" alt="one and two效果图" />

#### 传统目标检测算法
原理：滑动窗口法+传统机器学习分类器

<img width="50%" src="https://i.loli.net/2020/04/06/25etcPVKwn1z7gb.jpg" alt="传统目标检测" />

缺点：
1. 识别效果不够好，准确率不高
2. 计算量及较大，运行速度慢
3. 可能会出现多个正确识别的结果

#### FCN
原理：滑动窗口法+CNN提升识别的准确率
解决了传统目标检测中需要针对每个滑动窗口计算分类的效率问题，使用FCN可以一次性计算。

<img width="50%" src="https://i.loli.net/2020/04/06/R81rLtlbj4uPNm2.jpg" alt="FCN" />

<img width="50%" src="https://i.loli.net/2020/04/06/YHGECgKUhsVJAjf.jpg" alt="FCN2" />

#### RCNN

<img width="60%" src="https://i.loli.net/2020/04/06/Zh6Gejk9K4rL8pl.jpg" alt="RCNN" />

<img width="60%" src="https://i.loli.net/2020/04/06/ycnjhArmeJkYKVx.jpg" alt="RCNN算法流程" />

**具体算法流程如下：**
1. 选择一个分类模型（比如AlexNet、VGGNet等）
2. 去掉最后一个全连接层，将分类数从1000改为N+1（注意这里+1是添加了背景分类，N值根据实际业务场景选定），对该模型做fine-tuning（主要目的是优化卷积层和池化层的参数）

<img width="60%" src="https://i.loli.net/2020/04/06/CtF87aJjST2fZeL.jpg" alt="RCNN流程分析" />

3. 对每个候选区域进行特征提取，resize区域大小，将第5个池化层的输出（即候选区提取到的特征）保存到硬盘

<img width="60%" src="https://i.loli.net/2020/04/06/gfpMmtRDnYe4b9G.jpg" alt="RCNN流程分析2" />

4. 使用pooling5输出的图像特征训练SVM分类器，判断此候选区内的物体类别。每个类别对应一个SVM
5. 使用pooling5输出的图像特征训练一个回归器（dx，dy，dw，dh）。其中，dx是水平平移，dy是垂直平移，dw是宽度缩放，dh是高度缩放。在测试阶段，使用回归器调整候选框位置。

#### SPP-Net

<img width="60%" src="https://i.loli.net/2020/04/06/e32O86LCG7JFTsM.jpg" alt="SPP" />

SPP-Net针对RCNN做了改进，重点是：
1. 对原图只做一次卷积操作，就可以得到每个候选区域的特征。而不是类似RCNN对2000个候选区分别做CNN。
2. 使用了金字塔池化层技术，保证了原始候选区不管什么形状都可以得到同样尺寸的输出，而不是类似RCNN中将每个不同尺寸的候选区调整至相同大小。（4x4+2x2=20个值）

<img width="60%" src="https://i.loli.net/2020/04/06/tY2pAHr5amG1zd4.jpg" alt="金字塔池化层" />

经过实验证明，SPP-Net图像检测速度比RCNN提高了约100倍。

#### Fast RCNN

<img width="60%" src="https://i.loli.net/2020/04/06/AKcEBDu3avneIr5.jpg" alt="Fast RCNN" />

Fast RCNN针对SPP-Net做了改进，重点是：
1. 使用了ROI Pooling（是金字塔池化层的一种简单化的形式）

<img width="60%" src="https://i.loli.net/2020/04/06/EPS5q7tFzWAxr8N.jpg" alt="ROI Pooling" />

2. 将回归放进了神经网络内部，作为了一个整体，而不是单独地训练回归器和分类器

<img width="60%" src="https://i.loli.net/2020/04/06/478TSbjWtCmoLD3.jpg" alt="Fast RCNN对比" />


#### Faster RCNN

<img width="60%" src="https://i.loli.net/2020/04/06/wWrFczhEGp4J5d3.jpg" alt="Faster RCNN" />

<img width="60%" src="https://i.loli.net/2020/04/07/lQxKi7ONImoEUXH.jpg" alt="Faster RCNN网络架构" />

Faster RCNN针对Fast RCNN做了改进，重点是：
1. 加入了专门生成候选区的神经网络RPN，代替Fast RCNN中Selective Search方法

<img width="60%" src="https://i.loli.net/2020/04/07/DAwVKJrcMFQtWsT.jpg" alt="RPN" />

2. RPN中引入了anchor机制（每个点生成9个anchor）

<img width="60%" src="https://i.loli.net/2020/04/07/9BoNEROQKkZruP8.jpg" alt="anchor" />

<img width="60%" src="https://i.loli.net/2020/04/07/R7SAvjx18gwYuWn.jpg" alt="Faster RCNN训练流程" />

#### SSD

<img width="60%" src="https://i.loli.net/2020/04/07/1yzKFlC96QLdTmU.jpg" alt="SSD算法" />

观察上图，会看到每一层都有指向尾层特征的连线，尾层特征会收集到不同尺寸的特征图。一方面，浅层特征和深层特征包含的信息是不一样的，另一方面，每个层对应的感受野也不同，可以检测不同大小的目标物体。

**SSD算法流程：**

<img width="60%" src="https://i.loli.net/2020/04/07/ElnaqCUMHZcguVP.jpg" alt="SSD流程" />

SSD中使用到了hard negative mining和data augmentation优化手段：
1. hard negative mining

<img width="60%" src="https://i.loli.net/2020/04/07/YnPgFjbCGukophx.jpg" alt="hard" />

2. data augmentation

<img width="60%" src="https://i.loli.net/2020/04/06/xXFBepOmrKWZbvH.jpg" alt="DA" />

**SSD结果分析：**
1. 更多的feature map可以得到更好的结果
2. 使用图片边界的标注框比不使用图片边界的标注框效果更好

**SSD缺点：**
<img width="60%" src="https://i.loli.net/2020/04/06/TFoOgdan5u1DWkY.jpg" alt="SSD缺点" />

#### YOLO V1

<img width="60%" src="https://i.loli.net/2020/04/06/mi3dH8eTSlfMhAV.jpg" alt="YOLO V1" />

<img width="60%" src="https://i.loli.net/2020/04/06/hTjtAGUbQo6Llzx.jpg" alt="YOLO V1结构" />

<img width="60%" src="https://i.loli.net/2020/04/06/QjX5gYpS6lZN3FI.jpg" alt="YOLO V1流程" />

<img width="60%" src="https://i.loli.net/2020/04/06/QmCOWNYDqR46Fdh.jpg" alt="YOLO V1流程2" />

<img width="60%" src="https://i.loli.net/2020/04/06/VYPAXvQ7w61N3kM.jpg" alt="YOLO V1代价函数" />

#### YOLO V2
<img width="60%" src="https://i.loli.net/2020/04/06/7wQRpLFd4DSXIBi.jpg" alt="YOLO V2" />

<img width="60%" src="https://i.loli.net/2020/04/06/G6sU8hSCXtTf5Hi.jpg" alt="YOLO V2-2" />

<img width="60%" src="https://i.loli.net/2020/04/06/m9DtxjwZgLsXJUq.jpg" alt="YOLO V2-3" />

<img width="60%" src="https://i.loli.net/2020/04/07/juO7Aahd5F4oxKH.jpg" alt="YOLO V2-4" />

<img width="60%" src="https://i.loli.net/2020/04/07/2TWdmixDeo4sSa5.jpg" alt="YOLO V2-4-2" />

<img width="60%" src="https://i.loli.net/2020/04/07/irOVv81PxykjFWA.jpg" alt="YOLO V2-5" />

<img width="60%" src="https://i.loli.net/2020/04/07/ua5T1ldexNUAEgP.jpg" alt="YOLO V2-6" />

#### YOLO V3
<img width="60%" src="https://i.loli.net/2020/04/07/6FXo5fy8h4dPTcz.jpg" alt="YOLO V3" />

### 目标分割算法
<img width="60%" src="https://i.loli.net/2020/04/07/k5vL2uNncryiTS9.jpg" alt="目标分割" />

目标分割的不同层次：
1. 普通分割——将不同类别物体的像素区域分开
2. 语义分割——在普通分割的基础上，分类出每一块区域的语义（判断是什么物体）
3. 实例分割——在语义分割的基础上，给每一个物体编号

#### FCN
<img width="60%" src="https://i.loli.net/2020/04/07/IctN5vsZrOheiVz.jpg" alt="FCN算法" />

<img width="60%" src="https://i.loli.net/2020/04/07/BiLvoNbCFq6JXZP.jpg" alt="FCN算法2" />

#### Mask RCNN
<img width="60%" src="https://i.loli.net/2020/04/07/eHZoD4v1fJlQASh.jpg" alt=" Mask RCNN" />

<img width="60%" src="https://i.loli.net/2020/04/07/UTti65ofFDQ7zaK.jpg" alt=" Mask RCNN架构" />